–µ–º—è –ú–°–ö: ' + getMoscowTime());
        });

        app.get('/heartbeat', (req, res) => {
            lastPingTime = Date.now();
           isAlive = true;
            res.send('OK');
        });

        app.server = app.listen(port, () => {
            console.log(`–í–µ–±-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${port}`);
            isAlive = true;
       lastPingTime = Date.now();
            reconnectAttempts = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –∑–∞–ø—É—Å–∫–µ
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
        app.server.on('error', (error) => {
            console.error('–û—à–∏–±–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞:', error);
         isAlive = false;
            
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                console.log(`–ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
                setTimeout(restartWebServer, RECONNECT_INTERVAL);
        } else {
                console.error('–ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                process.exit(1); // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å, —á—Ç–æ–±—ã —Å–∏—Å—Ç–µ–º–∞ –º–æ–≥–ª–∞ –µ–≥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å
            }
        });
    } catch (error) {
        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞:', error);
    isAlive = false;
        process.exit(1);
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∞–º–æ-–ø–∏–Ω–≥ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
setInterval(performSelfPing, 60000);
–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ Discord –∫–ª–∏–µ–Ω—Ç–∞
client.on('error', error => {
    console.error('Discord client error:', error);
    if (!client.ws.connection) {
        console.log('–ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Discord...');
        client.destroy();
        setTimeout(() => {
            client.login(process.env.DISCORD_TOKEN)
                .catch(err => console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ Discord:', err));
        }, 5000);
    }
});

lient.on('disconnect', () => {
    console.log('Bot disconnected! Attempting to reconnect...');
    setTimeout(() => {
        client.login(process.env.DISCORD_TOKEN)
            .catch(err => console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ Discord:', err));
    }, 5000);
});

// When the client is ready, run this code (only once)
client.once('ready', () => {
    console.log(`–ë–æ—Ç ${client.user.tag} –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!`);
    console.log(`–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ú–°–ö: ${getMoscowTime()}`);
});
// Handle voice state updates
client.on('voiceStateUpdate', async (oldState, newState) => {
    const logChannel = client.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;

    const member = newState.member;
    if (!member) return;
    // Create a more specific event identifier with a timestamp
    const eventTimestamp = Date.now();
    const eventId = `${member.id}-${oldState.channelID || 'none'}-${newState.channelID || 'none'}-${eventTimestamp}`;

    // Check if this event is a duplicate
    const lastEventTime = recentEvents.get(eventId);
    if (lastEventTime) {
(`Duplicate event detected for ${eventId}, skipping...`);
        return; // Skip duplicates
    }

    // Store the event with a timestamp
    recentEvents.set(eventId, eventTimestamp);
    // Clean up old events after the timeout
    setTimeout(() => recentEvents.delete(eventId), EVENT_TIMEOUT);

    const currentTime = getMoscowTime();
    const username = member.user.username; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ username –±–µ–∑ –¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞—Ç–æ—Ä–∞

    try {
        // User joined a voice channel
        if (!oldState.channel && newState.channel) {
            const embed = {
                color: 0xFF0000,
                author: {
                    name: `${username} –∑–∞—à–µ–ª –≤ –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–∞–Ω–∞–ª`,
                    icon_url: member.user.displayAvatarURL()
               },                description: `–ö–∞–Ω–∞–ª: **${newState.channel.name}**`,                fields: [                    .channel.name}**`,
                       inline: false
                    }
                ],
                footer: {
                    text: `ID —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${member.id} ‚Ä¢ ${currentTime}`
              }       };gChannel.send({ embed });                // User left a voice channel        else if (oldState.channel && !newState.channel) {            const embed = {                color: 0x99AAb5,                author: {                   name: `${username} –ø–æ–∫–∏–Ω—É–ª –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–∞–Ω–∞–ª`,                    icon_url: member.user.displayAvatarURL()                                description: `üî¥ **${oldState.channel.name}**`               footer: {                    text: `ID —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${member.id} ‚Ä¢ ${currentTime}`
                }
            };
            await logChannel.send({ embed });
        }
        // User switched voice channels
(oldState.channel && newState.channel && oldState.channel.id !== newState.channel.id) {
            const embed = {
               color: 0xFF0000,
                author: {
                    name: `${username} –ø–µ—Ä–µ—à–µ–ª –≤ –¥—Ä—É–≥–æ–π –≥–æ–ª–æ—Å–æ–≤–æ–π –∫–∞–Ω–∞–ª`,
                    icon_url: member.user.displayAvatarURL()
                },
         fields: [
                    {
                        name: '–ü—Ä–µ–¥—ã–¥—É—â–∏–π –∫–∞–Ω–∞–ª:',
                        value: `üî¥ **${oldState.channel.name}**`,
                        inline: true
                    },
            {
                        name: '–ù–æ–≤—ã–π –∫–∞–Ω–∞–ª:',
                        value: `üî¥ **${newState.channel.name}**`,
      inline: true
                    }
                ],
                footer: {
                   text: `ID —É—á–∞—Å—Ç–Ω–∏–∫–∞: ${member.id} ‚Ä¢ ${currentTime}`
                }
           };
require('dotenv').config();
const { Client, Intents } = require('discord.js');
const express = require('express');
const app = express();
 = process.env.PORT || 8080;

/ Create a new client instance
const client = new Client({ 
    intents: [
        Intents.FLAGS.GUILDS,
     Intents.FLAGS.GUILD_MEMBERS,
        Intents.FLAGS.GUILD_VOICE_STATES
    ]
);

// ID of the text channel where logs will be sent
const LOG_CHANNEL_ID = '1364912337965813850';
/ Function to get Moscow time
function getMoscowTime() {
  
        'Sunday': '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ',
        'Monday': '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
        'Tuesday': '–í—Ç–æ—Ä–Ω–∏–∫',
sday': '–°—Ä–µ–¥–∞',
        'Thursday': '–ß–µ—Ç–≤–µ—Ä–≥',
       'Friday': '–ü—è—Ç–Ω–∏—Ü–∞',
        'Saturday': '–°

    const date = new Date();
   const moscowDate = new Date(date.toLocaleString('en-US', { timeZone: 'Europe/Moscow' }));
    
   const dayEn = moscowDate.toLocaleString('en-US', { weekday: 'long' });
= daysRu[day
    
    const hou

/ When the client is ready, run this code (only once)
client.once('ready', () => {
   console.log(`–ë–æ—Ç ${client.user.tag} –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!`);
    console.log(`–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ú–°–ö: ${getMoscowTime()}`);
// Voice state update handler
client.on('voiceStateUpdate', async (
